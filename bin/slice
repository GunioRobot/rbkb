#!/usr/bin/env ruby
# (emonti at matasano) Matasano Security LLC
#
# slice.rb : returns a slice from input
# just a shell interface to a string slice operation
#
# Usage: slice [options] start (no args when using -r|-x)
#     -h, --help                       Show this message
#     -v, --version                    Show version and exit
#     -f, --file FILENAME              Input from FILENAME
#     -r, --range=START[:END]          Start and optional end range
#     -x, --hexrange=START[:END]       same, but in hex
#

require 'rbkb/util'
require 'rbkb/extends'

OPTS = {:last => -1}
arg = bkb_stdargs(nil, OPTS)
arg = bkb_inpargs(arg, OPTS)

arg.banner += " start (no args when using -r|-x|)"

arg.on("-r", "--range=START[:END]", "Start and optional end range") do |r|

  raise "-x and -r are mutually exclusive" if OPTS[:first]

  unless m=/^(-?[0-9]+)(?::(-?[0-9]+))?$/.match(r)
    raise "invalid range #{r.inspect}"
  end

  OPTS[:first] = $1.to_i
  OPTS[:last] = $2.to_i if $2
end

arg.on("-x", "--hexrange=START[:END]", "same, but in hex") do |r|

  raise "-x and -r are mutually exclusive" if OPTS[:first]

  unless m=/^(-?[0-9a-f]+)(?::(-?[0-9a-f]+))?$/i.match(r)
    raise "invalid range #{r.inspect}"
  end

  OPTS[:first]=($1[0,1] == '-')? ($1[1..-1]).hex_to_num * -1 : $1.hex_to_num
  if $2
    OPTS[:last]=($2[0,1] == '-')? ($2[1..-1]).hex_to_num * -1 : $2.hex_to_num
  end
end

begin
  arg.parse!

  OPTS[:first] ||= ARGV.shift

  unless( ARGV.length != 1 and (
              OPTS[:first].kind_of?(Numeric) or 
              /^-?\d+$/.match(OPTS[:first]) )
        )
    raise "bad arguments"
  end

  OPTS[:first] = OPTS[:first].to_i

  OPTS[:indat] ||= STDIN.read()

  # drumroll... and substring:
  STDOUT.write OPTS[:indat][ OPTS[:first] .. OPTS[:last] ]

rescue
  bail "Error: #{$!}\n#{arg}"
end

